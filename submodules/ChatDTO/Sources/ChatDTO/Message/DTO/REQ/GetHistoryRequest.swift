//
// GetHistoryRequest.swift
// Copyright (c) 2022 ChatDTO
//
// Created by Hamed Hosseini on 12/14/22

import Foundation

public struct GetHistoryRequest: Encodable, UniqueIdProtocol, TypeCodeIndexProtocol, Sendable {
    /// The unique id of the thread.
    public let threadId: Int
    
    /// The start or offest to begin the fetch data.
    public var offset: Int
    
    /// Number of items to possibly return by this request.
    public var count: Int
    
    /// The start time of fetching messages in milliseconds.
    public let fromTime: UInt?
    
    /// The start time of fetching messages in nanoseconds.
    public let fromTimeNanos: UInt?
    
    /// Id of a unique message by setting this property you also need to set threadId.
    public let messageId: Int?
    
    /// Type of messages you want to fetch, for example, pictures in a conversation.
    public let messageType: Int?
    
    /// Seraching by metadatCriteria.
    public let metadataCriteria: SearchMetadataCriteria?
    
    /// The order of fetching it could be either **asc** or **desc**.
    public let order: String?
    
    /// A string query to fetch messages.
    public let query: String?
    
    /// The end time of fetching messages in milliseconds.
    public let toTime: UInt?
    
    /// Fetching messages by hashtag string.
    public let hashtag: String?
    
    /// The end time of fetching messages in nanoseconds.
    public let toTimeNanos: UInt?
    
    /// Fetch messages by uniqueId.
    public let uniqueIds: [String]?
    
    /// Fetch messages of a specific user.
    public let userId: Int?
    
    /// Fetch by message therad id.
    public var messageThreadId: Int?
    
    /// Fetch messages where this id is equal to start of history.
    public var firstMessageId: Int?
    
    /// Fetch messages where this id is equal to last of history.
    public var lastMessageId: Int?
    
    /// Fetch messages by their sender IDs.
    public var senderId: Int?
    
    /// Fetch messages by history time.
    public var historyTime: UInt?
    
    /// Fetch all mentioned messages inside a conversation.
    public var allMentioned: Bool?
    
    /// Fetch all unread mentioned messages inside a conversation.
    public var unreadMentioned: Bool?
    
    /// Fetch all messages by last message time.
    public var lastMessageTime: UInt?
    
    /// Fetch all messages by history end time.
    public var historyEndTime: UInt?
    
    /// This property prevent to write to cache when you only need to view messages of a thread pass true if you need to only view messages.
    public var readOnly: Bool = false
    
    /// Fetch all new messages only.
    public var newMessages: Bool?
    
    /// This uniqueId will be generated by the SDK.
    public let uniqueId: String
    
    /// This typeCodeIndex will be generated by the SDK, don't try to mutate this typeCodeIndex at runtime.
    public var typeCodeIndex: Index
    
    /// An internal computed property to prevent sending out-of-bounds requests.
    public var nonNegativeOffset: Int {
        max(0, offset)
    }
    
    public init(threadId: Int,
                count: Int? = nil,
                fromTime: UInt? = nil,
                fromTimeNanos: UInt? = nil,
                messageId: Int? = nil,
                messageType: Int? = nil,
                metadataCriteria: SearchMetadataCriteria? = nil,
                offset: Int? = nil,
                order: String? = nil,
                query: String? = nil,
                toTime: UInt? = nil,
                toTimeNanos: UInt? = nil,
                uniqueIds: [String]? = nil,
                userId: Int? = nil,
                hashtag: String? = nil,
                messageThreadId: Int? = nil,
                firstMessageId: Int? = nil,
                lastMessageId: Int? = nil,
                senderId: Int? = nil,
                historyTime: UInt? = nil,
                allMentioned: Bool? = nil,
                unreadMentioned: Bool? = nil,
                lastMessageTime: UInt? = nil,
                historyEndTime: UInt? = nil,
                readOnly: Bool = false,
                newMessages: Bool? = nil,
                typeCodeIndex: TypeCodeIndexProtocol.Index = 0)
    {
        self.threadId = threadId
        self.count = count ?? 25
        self.offset = offset ?? -1
        self.fromTime = fromTime
        self.fromTimeNanos = fromTimeNanos
        self.messageId = messageId
        self.messageType = messageType
        self.metadataCriteria = metadataCriteria
        self.order = order
        self.query = query
        self.toTime = toTime
        self.hashtag = hashtag
        self.toTimeNanos = toTimeNanos
        self.uniqueIds = uniqueIds
        self.userId = userId
        self.messageThreadId = messageThreadId
        self.firstMessageId = firstMessageId
        self.lastMessageId = lastMessageId
        self.senderId = senderId
        self.historyTime = historyTime
        self.allMentioned = allMentioned
        self.unreadMentioned = unreadMentioned
        self.lastMessageTime = lastMessageTime
        self.historyEndTime = historyEndTime
        self.readOnly = readOnly
        self.newMessages = newMessages
        self.uniqueId = UUID().uuidString
        self.typeCodeIndex = typeCodeIndex
    }

    private enum CodingKeys: String, CodingKey {
        case count
        case offset
        case fromTime
        case fromTimeNanos
        case messageId = "id"
        case messageType
        case metadataCriteria
        case order
        case query
        case toTime
        case hashtag
        case toTimeNanos
        case uniqueIds
        case userId
        case messageThreadId
        case firstMessageId
        case lastMessageId
        case senderId
        case historyTime
        case allMentioned
        case unreadMentioned
        case lastMessageTime
        case historyEndTime
        case newMessages
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(count, forKey: .count)
        try container.encode(nonNegativeOffset, forKey: .offset)
        try container.encodeIfPresent(fromTime, forKey: .fromTime)
        try container.encodeIfPresent(fromTimeNanos, forKey: .fromTimeNanos)
        try container.encodeIfPresent(toTime, forKey: .toTime)
        try container.encodeIfPresent(toTimeNanos, forKey: .toTimeNanos)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(query, forKey: .query)
        try container.encodeIfPresent(messageId, forKey: .messageId)
        try container.encodeIfPresent(metadataCriteria, forKey: .metadataCriteria)
        try container.encodeIfPresent(uniqueIds, forKey: .uniqueIds)
        try container.encodeIfPresent(messageType, forKey: .messageType)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(hashtag, forKey: .hashtag)
        try container.encodeIfPresent(messageThreadId, forKey: .messageThreadId)
        try container.encodeIfPresent(firstMessageId, forKey: .firstMessageId)
        try container.encodeIfPresent(lastMessageId, forKey: .lastMessageId)
        try container.encodeIfPresent(senderId, forKey: .senderId)
        try container.encodeIfPresent(historyTime, forKey: .historyTime)
        try container.encodeIfPresent(allMentioned, forKey: .allMentioned)
        try container.encodeIfPresent(unreadMentioned, forKey: .unreadMentioned)
        try container.encodeIfPresent(lastMessageTime, forKey: .lastMessageTime)
        try container.encodeIfPresent(historyEndTime, forKey: .historyEndTime)
        try container.encodeIfPresent(newMessages, forKey: .newMessages)
    }
}
